# コーディング規約
- 最初に必ず Kasetsu::Base を use する
  - strict, warnings, utf8 などが有効になり, よく使うモジュールの関数が import される
- クラスビルダー: Mouse
  - Moo じゃだめな理由あったっけ?
- サブルーチンの引数は Type::Params を利用してチェックする
- 返り値を明示したい場合は Function::Return を利用する
- エラーの扱い
  - クラス不変表明, 事前条件, 事後条件 は Carp::Assert の assert で記述
    - クラス不変表明はコンストラクタの引数の型, 事前条件はメソッドの引数の型, 事後条件はメソッドの返り値の型
    - Value Objectをしっかり作って型で表現できる場合は代わりに型チェックを行う
  - 契約が破られたときに例外を投げる
    - 契約が破られたとき = エラー発生の原因がサブルーチンの呼び出し側にもサブルーチン内部の処理にもない場合, メモリ確保失敗など
    - できるだけ例外クラスで例外を投げる
  - アプリケーションエラーはGoみたいに多値返却する
- 未定義値の扱い
  - 未定義値が返されうるメソッド, 変数名には接頭辞 `maybe_` をつける

## Controller
- Controller該当するところは基本的にcgiファイルに書く
  - 共通処理などは `Kasetsu::Controller` 以下にモジュールを作って再利用する
  - 最終的には cgi ファイルにかかれている処理をすべてモジュールに移してルーティングに応じて処理を呼び出せるようにしたい
- CGI モジュールを利用してリクエストパラメータを処理する
- View(HTMLのテンプレートやViewModelも含む)にはDTOやService層のModelは渡してはいけない

### 備考
- バリデーションは基本 UseCase にまかせる
  - バリデーションは UseCase の1つと捉える
  - そもそもリクエストして来ているのがおかしい値はバリデーションしてよい
    - UseCase にそのまま渡すと危険なものなど

## UseCase
- UseCase から Controller には次の値が渡せる
  - DTO(Read系の処理で多い)
  - UseCaseのモデル
- UseCase で作成するモデルには処理で利用する最低限のデータのみを保持すること
  - DTO から必要なもののみ取り出して変換する

## テンプレート
- 関数を定義したperlスクリプトをテンプレートとする
  - 理由
    - cgi に埋め込みやすい
    - Controller から渡される値を明示的にできる
- 最初に必ず Kasetsu::Base::Template を use する
  - Kasetsu::Base の use + `html_escape` などのテンプレート向けのユーティリティ関数が提供される
  - Kasetsu::Base --template でもいいかも(拡張しやすい実装でどちらを選択するか考える)

## テスト

### 単体テスト
- t/unit 以下にモジュールごとに書く
- ファイル名は `Kasetsu::UseCase::Visitor` -> `t/unit/kasetsu/use_case/visitor.t` というようにする
- モジュールが巨大な場合はメソッドごとにテストファイルを作成しても良い
  - ただしその前にメソッドごとにテスト対象のモジュールを分割することを強く推奨
  - 例外はフレームワーク的なことをしているモジュールのみ

### 結合テスト
- t/integration 以下に置く

### kasetsu 独自のテストライブラリ
テスト用のセットアップ関数, 独自のテスト関数などがつくりたくなったら `lib/Test/Kasetsu` に置く

